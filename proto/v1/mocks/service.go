// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	cacheservice_v1 "github.com/mdevilliers/cache-service/proto/v1"
	"google.golang.org/grpc"
)

type FakeCacheClient struct {
	GetByKeyStub        func(context.Context, *cacheservice_v1.GetByKeyRequest, ...grpc.CallOption) (*cacheservice_v1.GetByKeyResponse, error)
	getByKeyMutex       sync.RWMutex
	getByKeyArgsForCall []struct {
		arg1 context.Context
		arg2 *cacheservice_v1.GetByKeyRequest
		arg3 []grpc.CallOption
	}
	getByKeyReturns struct {
		result1 *cacheservice_v1.GetByKeyResponse
		result2 error
	}
	getByKeyReturnsOnCall map[int]struct {
		result1 *cacheservice_v1.GetByKeyResponse
		result2 error
	}
	GetRandomNStub        func(context.Context, *cacheservice_v1.GetRandomNRequest, ...grpc.CallOption) (*cacheservice_v1.GetRandomNResponse, error)
	getRandomNMutex       sync.RWMutex
	getRandomNArgsForCall []struct {
		arg1 context.Context
		arg2 *cacheservice_v1.GetRandomNRequest
		arg3 []grpc.CallOption
	}
	getRandomNReturns struct {
		result1 *cacheservice_v1.GetRandomNResponse
		result2 error
	}
	getRandomNReturnsOnCall map[int]struct {
		result1 *cacheservice_v1.GetRandomNResponse
		result2 error
	}
	PurgeStub        func(context.Context, *cacheservice_v1.PurgeRequest, ...grpc.CallOption) (*cacheservice_v1.PurgeResponse, error)
	purgeMutex       sync.RWMutex
	purgeArgsForCall []struct {
		arg1 context.Context
		arg2 *cacheservice_v1.PurgeRequest
		arg3 []grpc.CallOption
	}
	purgeReturns struct {
		result1 *cacheservice_v1.PurgeResponse
		result2 error
	}
	purgeReturnsOnCall map[int]struct {
		result1 *cacheservice_v1.PurgeResponse
		result2 error
	}
	SetStub        func(context.Context, *cacheservice_v1.SetRequest, ...grpc.CallOption) (*cacheservice_v1.SetResponse, error)
	setMutex       sync.RWMutex
	setArgsForCall []struct {
		arg1 context.Context
		arg2 *cacheservice_v1.SetRequest
		arg3 []grpc.CallOption
	}
	setReturns struct {
		result1 *cacheservice_v1.SetResponse
		result2 error
	}
	setReturnsOnCall map[int]struct {
		result1 *cacheservice_v1.SetResponse
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeCacheClient) GetByKey(arg1 context.Context, arg2 *cacheservice_v1.GetByKeyRequest, arg3 ...grpc.CallOption) (*cacheservice_v1.GetByKeyResponse, error) {
	fake.getByKeyMutex.Lock()
	ret, specificReturn := fake.getByKeyReturnsOnCall[len(fake.getByKeyArgsForCall)]
	fake.getByKeyArgsForCall = append(fake.getByKeyArgsForCall, struct {
		arg1 context.Context
		arg2 *cacheservice_v1.GetByKeyRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetByKey", []interface{}{arg1, arg2, arg3})
	fake.getByKeyMutex.Unlock()
	if fake.GetByKeyStub != nil {
		return fake.GetByKeyStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getByKeyReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCacheClient) GetByKeyCallCount() int {
	fake.getByKeyMutex.RLock()
	defer fake.getByKeyMutex.RUnlock()
	return len(fake.getByKeyArgsForCall)
}

func (fake *FakeCacheClient) GetByKeyCalls(stub func(context.Context, *cacheservice_v1.GetByKeyRequest, ...grpc.CallOption) (*cacheservice_v1.GetByKeyResponse, error)) {
	fake.getByKeyMutex.Lock()
	defer fake.getByKeyMutex.Unlock()
	fake.GetByKeyStub = stub
}

func (fake *FakeCacheClient) GetByKeyArgsForCall(i int) (context.Context, *cacheservice_v1.GetByKeyRequest, []grpc.CallOption) {
	fake.getByKeyMutex.RLock()
	defer fake.getByKeyMutex.RUnlock()
	argsForCall := fake.getByKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCacheClient) GetByKeyReturns(result1 *cacheservice_v1.GetByKeyResponse, result2 error) {
	fake.getByKeyMutex.Lock()
	defer fake.getByKeyMutex.Unlock()
	fake.GetByKeyStub = nil
	fake.getByKeyReturns = struct {
		result1 *cacheservice_v1.GetByKeyResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeCacheClient) GetByKeyReturnsOnCall(i int, result1 *cacheservice_v1.GetByKeyResponse, result2 error) {
	fake.getByKeyMutex.Lock()
	defer fake.getByKeyMutex.Unlock()
	fake.GetByKeyStub = nil
	if fake.getByKeyReturnsOnCall == nil {
		fake.getByKeyReturnsOnCall = make(map[int]struct {
			result1 *cacheservice_v1.GetByKeyResponse
			result2 error
		})
	}
	fake.getByKeyReturnsOnCall[i] = struct {
		result1 *cacheservice_v1.GetByKeyResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeCacheClient) GetRandomN(arg1 context.Context, arg2 *cacheservice_v1.GetRandomNRequest, arg3 ...grpc.CallOption) (*cacheservice_v1.GetRandomNResponse, error) {
	fake.getRandomNMutex.Lock()
	ret, specificReturn := fake.getRandomNReturnsOnCall[len(fake.getRandomNArgsForCall)]
	fake.getRandomNArgsForCall = append(fake.getRandomNArgsForCall, struct {
		arg1 context.Context
		arg2 *cacheservice_v1.GetRandomNRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetRandomN", []interface{}{arg1, arg2, arg3})
	fake.getRandomNMutex.Unlock()
	if fake.GetRandomNStub != nil {
		return fake.GetRandomNStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getRandomNReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCacheClient) GetRandomNCallCount() int {
	fake.getRandomNMutex.RLock()
	defer fake.getRandomNMutex.RUnlock()
	return len(fake.getRandomNArgsForCall)
}

func (fake *FakeCacheClient) GetRandomNCalls(stub func(context.Context, *cacheservice_v1.GetRandomNRequest, ...grpc.CallOption) (*cacheservice_v1.GetRandomNResponse, error)) {
	fake.getRandomNMutex.Lock()
	defer fake.getRandomNMutex.Unlock()
	fake.GetRandomNStub = stub
}

func (fake *FakeCacheClient) GetRandomNArgsForCall(i int) (context.Context, *cacheservice_v1.GetRandomNRequest, []grpc.CallOption) {
	fake.getRandomNMutex.RLock()
	defer fake.getRandomNMutex.RUnlock()
	argsForCall := fake.getRandomNArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCacheClient) GetRandomNReturns(result1 *cacheservice_v1.GetRandomNResponse, result2 error) {
	fake.getRandomNMutex.Lock()
	defer fake.getRandomNMutex.Unlock()
	fake.GetRandomNStub = nil
	fake.getRandomNReturns = struct {
		result1 *cacheservice_v1.GetRandomNResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeCacheClient) GetRandomNReturnsOnCall(i int, result1 *cacheservice_v1.GetRandomNResponse, result2 error) {
	fake.getRandomNMutex.Lock()
	defer fake.getRandomNMutex.Unlock()
	fake.GetRandomNStub = nil
	if fake.getRandomNReturnsOnCall == nil {
		fake.getRandomNReturnsOnCall = make(map[int]struct {
			result1 *cacheservice_v1.GetRandomNResponse
			result2 error
		})
	}
	fake.getRandomNReturnsOnCall[i] = struct {
		result1 *cacheservice_v1.GetRandomNResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeCacheClient) Purge(arg1 context.Context, arg2 *cacheservice_v1.PurgeRequest, arg3 ...grpc.CallOption) (*cacheservice_v1.PurgeResponse, error) {
	fake.purgeMutex.Lock()
	ret, specificReturn := fake.purgeReturnsOnCall[len(fake.purgeArgsForCall)]
	fake.purgeArgsForCall = append(fake.purgeArgsForCall, struct {
		arg1 context.Context
		arg2 *cacheservice_v1.PurgeRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("Purge", []interface{}{arg1, arg2, arg3})
	fake.purgeMutex.Unlock()
	if fake.PurgeStub != nil {
		return fake.PurgeStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.purgeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCacheClient) PurgeCallCount() int {
	fake.purgeMutex.RLock()
	defer fake.purgeMutex.RUnlock()
	return len(fake.purgeArgsForCall)
}

func (fake *FakeCacheClient) PurgeCalls(stub func(context.Context, *cacheservice_v1.PurgeRequest, ...grpc.CallOption) (*cacheservice_v1.PurgeResponse, error)) {
	fake.purgeMutex.Lock()
	defer fake.purgeMutex.Unlock()
	fake.PurgeStub = stub
}

func (fake *FakeCacheClient) PurgeArgsForCall(i int) (context.Context, *cacheservice_v1.PurgeRequest, []grpc.CallOption) {
	fake.purgeMutex.RLock()
	defer fake.purgeMutex.RUnlock()
	argsForCall := fake.purgeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCacheClient) PurgeReturns(result1 *cacheservice_v1.PurgeResponse, result2 error) {
	fake.purgeMutex.Lock()
	defer fake.purgeMutex.Unlock()
	fake.PurgeStub = nil
	fake.purgeReturns = struct {
		result1 *cacheservice_v1.PurgeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeCacheClient) PurgeReturnsOnCall(i int, result1 *cacheservice_v1.PurgeResponse, result2 error) {
	fake.purgeMutex.Lock()
	defer fake.purgeMutex.Unlock()
	fake.PurgeStub = nil
	if fake.purgeReturnsOnCall == nil {
		fake.purgeReturnsOnCall = make(map[int]struct {
			result1 *cacheservice_v1.PurgeResponse
			result2 error
		})
	}
	fake.purgeReturnsOnCall[i] = struct {
		result1 *cacheservice_v1.PurgeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeCacheClient) Set(arg1 context.Context, arg2 *cacheservice_v1.SetRequest, arg3 ...grpc.CallOption) (*cacheservice_v1.SetResponse, error) {
	fake.setMutex.Lock()
	ret, specificReturn := fake.setReturnsOnCall[len(fake.setArgsForCall)]
	fake.setArgsForCall = append(fake.setArgsForCall, struct {
		arg1 context.Context
		arg2 *cacheservice_v1.SetRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	fake.recordInvocation("Set", []interface{}{arg1, arg2, arg3})
	fake.setMutex.Unlock()
	if fake.SetStub != nil {
		return fake.SetStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.setReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCacheClient) SetCallCount() int {
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	return len(fake.setArgsForCall)
}

func (fake *FakeCacheClient) SetCalls(stub func(context.Context, *cacheservice_v1.SetRequest, ...grpc.CallOption) (*cacheservice_v1.SetResponse, error)) {
	fake.setMutex.Lock()
	defer fake.setMutex.Unlock()
	fake.SetStub = stub
}

func (fake *FakeCacheClient) SetArgsForCall(i int) (context.Context, *cacheservice_v1.SetRequest, []grpc.CallOption) {
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	argsForCall := fake.setArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCacheClient) SetReturns(result1 *cacheservice_v1.SetResponse, result2 error) {
	fake.setMutex.Lock()
	defer fake.setMutex.Unlock()
	fake.SetStub = nil
	fake.setReturns = struct {
		result1 *cacheservice_v1.SetResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeCacheClient) SetReturnsOnCall(i int, result1 *cacheservice_v1.SetResponse, result2 error) {
	fake.setMutex.Lock()
	defer fake.setMutex.Unlock()
	fake.SetStub = nil
	if fake.setReturnsOnCall == nil {
		fake.setReturnsOnCall = make(map[int]struct {
			result1 *cacheservice_v1.SetResponse
			result2 error
		})
	}
	fake.setReturnsOnCall[i] = struct {
		result1 *cacheservice_v1.SetResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeCacheClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getByKeyMutex.RLock()
	defer fake.getByKeyMutex.RUnlock()
	fake.getRandomNMutex.RLock()
	defer fake.getRandomNMutex.RUnlock()
	fake.purgeMutex.RLock()
	defer fake.purgeMutex.RUnlock()
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeCacheClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ cacheservice_v1.CacheClient = new(FakeCacheClient)
